<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simon's Christmas Gift for Missionaries</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #020a0f 0%, #000 100%);
            color: white; 
            font-family: 'Cinzel', serif;
            touch-action: none; 
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300&display=swap');

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-container {
            /* Updated top position to avoid overlap with UI buttons */
            position: absolute; top: 100px; right: 16px; width: 80px; height: 106px; 
            border-radius: 12px; overflow: hidden; z-index: 10;
            border: 1px solid rgba(255, 215, 0, 0.3);
            background: #000;
            opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        .glass-panel {
            background: rgba(10, 25, 30, 0.75); 
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.7);
        }

        /* Form Inputs Styling */
        .glass-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #FFD700;
            font-family: 'Cinzel', serif;
            outline: none;
            transition: all 0.3s;
        }
        .glass-input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }
        select.glass-input option {
            background: #020a0f;
            color: white;
        }

        #loading {
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            transition: opacity 1s ease-out;
        }

        .state-badge {
            font-size: 0.65rem; padding: 3px 6px; border-radius: 4px;
            background: rgba(255,255,255,0.05); color: #888; transition: all 0.3s;
            display: flex; align-items: center; gap: 6px;
        }
        .state-active {
            background: rgba(255, 215, 0, 0.2); color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.4); font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }
        
        .music-active {
            color: #FFD700 !important;
            border-color: rgba(255, 215, 0, 0.5) !important;
            animation: pulse-gold 2s infinite;
        }
        
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-yellow-500 mb-6"></div>
        <div class="text-yellow-400 text-2xl font-serif tracking-[0.2em] drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">LIGHT THE WORLD</div>
    </div>

    <audio id="bg-music" loop>
        <source src="Silent_night_holy_night.mp3" type="audio/mpeg">
    </audio>

    <div id="canvas-container"></div>

    <div id="video-container">
        <video id="video-input" width="320" height="240" playsinline muted autoplay></video>
    </div>

    <!-- UI Overlay -->
    <div class="absolute inset-0 pointer-events-none flex flex-col justify-between z-20">
        <!-- Header -->
        <div class="p-4 mt-2 flex justify-between items-start">
            <div class="glass-panel px-3 py-2 flex flex-col gap-1 min-w-[130px]">
                <div class="flex items-center gap-2 border-b border-white/10 pb-1 mb-1">
                    <div id="status-dot" class="w-2 h-2 rounded-full bg-gray-500 transition-all duration-500 shadow-[0_0_5px_rgba(0,0,0,0.5)]"></div>
                    <span id="status-text" class="text-[10px] font-bold text-gray-200 tracking-wider">SYSTEM READY</span>
                </div>
                <div class="flex flex-col gap-1">
                    <div id="badge-tree" class="state-badge state-active"><span>‚úä</span> Tree</div>
                    <div id="badge-christus" class="state-badge"><span>üñê</span> Vision</div>
                    <div id="badge-zoom" class="state-badge"><span>‚úåÔ∏è</span> Zoom</div>
                </div>
            </div>
            
            <div class="flex gap-3">
                <button onclick="toggleMusic()" id="music-btn" class="glass-panel w-10 h-10 flex items-center justify-center text-gray-400 pointer-events-auto active:scale-95 hover:text-white transition-colors">
                    <i class="fa-solid fa-music text-base"></i>
                </button>
                <button onclick="toggleHelp()" class="glass-panel w-10 h-10 flex items-center justify-center text-yellow-400 pointer-events-auto active:scale-95 hover:text-yellow-200 transition-colors">
                    <i class="fa-solid fa-question text-base"></i>
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div class="absolute bottom-8 left-8 pointer-events-auto">
            <label class="glass-panel px-4 py-2 flex items-center gap-3 cursor-pointer hover:bg-white/10 active:scale-95 transition-all group ring-1 ring-white/10 hover:ring-yellow-500/50">
                <div class="w-8 h-8 rounded-full bg-gradient-to-br from-yellow-600 to-yellow-800 flex items-center justify-center shadow-lg group-hover:shadow-yellow-500/40 transition-all relative overflow-hidden">
                    <div class="absolute inset-0 bg-gradient-to-t from-transparent to-yellow-400/20 opacity-0 group-hover:opacity-100 transition-opacity"></div>
                    <i class="fa-solid fa-images text-white text-xs relative z-10"></i>
                </div>
                <div class="text-left">
                    <div class="text-[8px] text-gray-300 uppercase tracking-wider font-semibold">Memories</div>
                    <div class="text-xs font-bold text-white drop-shadow-sm">Upload Photos</div>
                </div>
                <input type="file" id="file-input" class="hidden" multiple accept="image/*">
            </label>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" style="opacity: 1;" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-lg pointer-events-auto transition-opacity duration-500">
        <div class="glass-panel p-8 max-w-md w-4/5 text-center transform scale-100 transition-transform border-yellow-500/20" id="help-box">
            <h3 class="text-yellow-400 font-serif text-2xl mb-6 tracking-[0.15em] border-b border-yellow-500/20 pb-4 drop-shadow-[0_0_8px_rgba(255,215,0,0.3)]">GESTURE GUIDE</h3>
            <div class="space-y-6 text-left pl-2">
                <div class="flex items-center gap-5">
                    <div class="w-12 h-12 flex items-center justify-center text-3xl bg-white/5 rounded-xl border border-white/10 shrink-0">‚úä</div>
                    <div>
                        <div class="text-white font-bold text-lg mb-0.5">FIST</div>
                        <div class="text-gray-400 text-sm">Show the Christmas Tree</div>
                    </div>
                </div>
                <div class="flex items-center gap-5">
                    <div class="w-12 h-12 flex items-center justify-center text-3xl bg-white/5 rounded-xl border border-white/10 shrink-0">üñê</div>
                    <div>
                        <div class="text-white font-bold text-lg mb-0.5">OPEN HAND</div>
                        <div class="text-gray-400 text-sm">Reveal the Vision (Move hand to rotate)</div>
                    </div>
                </div>
                <div class="flex items-center gap-5">
                    <div class="w-12 h-12 flex items-center justify-center text-3xl bg-white/5 rounded-xl border border-white/10 shrink-0">‚úåÔ∏è</div>
                    <div>
                        <div class="text-white font-bold text-lg mb-0.5">VICTORY SIGN</div>
                        <div class="text-gray-400 text-sm">Zoom in on Memories</div>
                    </div>
                </div>
            </div>
            <button onclick="openMissionaryForm()" class="mt-8 px-10 py-3 bg-gradient-to-r from-yellow-900/60 to-yellow-700/60 text-yellow-300 text-sm font-bold rounded-xl hover:from-yellow-800/60 hover:to-yellow-600/60 transition w-full pointer-events-auto border border-yellow-500/30 tracking-wider hover:shadow-[0_0_15px_rgba(255,215,0,0.2)]">BEGIN EXPERIENCE</button>
        </div>
    </div>

    <!-- Missionary Form Modal -->
    <div id="missionary-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-lg hidden opacity-0 transition-opacity duration-500 pointer-events-none">
        <div class="glass-panel p-8 max-w-sm w-full text-center border-yellow-500/20 transform scale-95 transition-transform" id="missionary-box">
            <h3 class="text-yellow-400 font-serif text-xl mb-6 tracking-[0.1em] border-b border-yellow-500/20 pb-4">WHO IS SERVING?</h3>
            
            <div class="mb-4 text-left">
                <label class="text-xs text-gray-400 block mb-1">Number of Missionaries</label>
                <select id="missionary-count" onchange="updateFormFields()" class="glass-input w-full p-2 rounded text-sm">
                    <option value="1">1 Missionary</option>
                    <option value="2">2 Missionaries</option>
                </select>
            </div>

            <!-- Missionary 1 -->
            <div class="space-y-3 mb-4 text-left">
                <div class="flex gap-2">
                    <select id="m1-title" class="glass-input w-1/3 p-2 rounded text-sm">
                        <option value="Elder">Elder</option>
                        <option value="Sister">Sister</option>
                    </select>
                    <input type="text" id="m1-name" placeholder="Last Name" class="glass-input w-2/3 p-2 rounded text-sm">
                </div>
            </div>

            <!-- Missionary 2 (Hidden by default) -->
            <div id="m2-container" class="space-y-3 mb-6 text-left hidden">
                <div class="flex gap-2">
                    <select id="m2-title" class="glass-input w-1/3 p-2 rounded text-sm">
                        <option value="Elder">Elder</option>
                        <option value="Sister">Sister</option>
                    </select>
                    <input type="text" id="m2-name" placeholder="Last Name" class="glass-input w-2/3 p-2 rounded text-sm">
                </div>
            </div>

            <button onclick="submitMissionaries()" class="mt-4 px-10 py-3 bg-gradient-to-r from-yellow-900/60 to-yellow-700/60 text-yellow-300 text-sm font-bold rounded-xl hover:from-yellow-800/60 hover:to-yellow-600/60 transition w-full pointer-events-auto border border-yellow-500/30 tracking-wider hover:shadow-[0_0_15px_rgba(255,215,0,0.2)]">ENTER VISION</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import TWEEN from 'three/addons/libs/tween.module.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        const CONFIG = {
            treeParticles: 2200,    
            spiritParticles: 5500,  
            photoCount: 12,         
            treeHeight: 65,
            treeRadius: 28,
            colors: {
                matteGreen: 0x005522,
                gold: 0xffcc00,
                red: 0xcc0000,
                spiritGold: 0xffeebb
            }
        };

        let scene, camera, renderer, composer;
        let mainGroup = new THREE.Group(); 
        let treeGroup = [];   
        let spiritGroup = []; 
        let photoTextures = [];
        let defaultPhotoTexture;
        let currentMode = 'tree'; 
        let time = 0;
        let isCameraReady = false;
        let rotatingPointLight;
        let audio;
        let cachedModelPoints = []; // Store GLB points
        
        let targetRotationX = 0;
        let targetRotationY = 0;
        let pinchStrength = 0;
        let zoomLevel = 1.0;

        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const videoContainer = document.getElementById('video-container');
        const loadingScreen = document.getElementById('loading');
        const videoInput = document.getElementById('video-input');
        const musicBtn = document.getElementById('music-btn');
        
        window.toggleHelp = () => {
            const el = document.getElementById('help-modal');
            const box = document.getElementById('help-box');
            if (el.style.opacity === '1') {
                el.style.opacity = '0'; el.style.pointerEvents = 'none'; box.style.transform = 'scale(0.95)';
            } else {
                el.style.opacity = '1'; el.style.pointerEvents = 'auto'; box.style.transform = 'scale(1)';
            }
        };

        window.openMissionaryForm = () => {
            // Start Music Immediately here
            startExperience();

            // Close Help
            const helpEl = document.getElementById('help-modal');
            const helpBox = document.getElementById('help-box');
            helpEl.style.opacity = '0'; helpEl.style.pointerEvents = 'none'; helpBox.style.transform = 'scale(0.95)';

            // Open Form
            const formEl = document.getElementById('missionary-modal');
            const formBox = document.getElementById('missionary-box');
            formEl.classList.remove('hidden');
            // Small timeout to allow display:block to apply before opacity transition
            setTimeout(() => {
                formEl.style.opacity = '1';
                formEl.style.pointerEvents = 'auto';
                formBox.style.transform = 'scale(1)';
            }, 50);
        };

        window.updateFormFields = () => {
            const count = document.getElementById('missionary-count').value;
            const m2 = document.getElementById('m2-container');
            if(count === '2') m2.classList.remove('hidden');
            else m2.classList.add('hidden');
        };

        window.submitMissionaries = () => {
            const count = document.getElementById('missionary-count').value;
            const t1 = document.getElementById('m1-title').value;
            const n1 = document.getElementById('m1-name').value.trim() || 'Missionary';
            
            let finalText = "Thank you for your service\nto the Lord,\n" + t1 + " " + n1;

            if(count === '2') {
                const t2 = document.getElementById('m2-title').value;
                const n2 = document.getElementById('m2-name').value.trim() || 'Missionary';
                finalText += "\nand " + t2 + " " + n2;
            }
            finalText += "!";

            // Initialize Spirit System with custom text
            initSpiritSystem(finalText);

            // Hide Form
            const formEl = document.getElementById('missionary-modal');
            formEl.style.opacity = '0'; 
            formEl.style.pointerEvents = 'none';
            setTimeout(() => formEl.classList.add('hidden'), 500);

            // Ensure Music is playing (idempotent if already started)
            startExperience();
        };

        window.toggleMusic = () => {
            if(!audio) audio = document.getElementById('bg-music');
            if(audio.paused) {
                audio.play().then(() => {
                    musicBtn.classList.add('music-active');
                    musicBtn.innerHTML = '<i class="fa-solid fa-volume-high text-lg"></i>';
                }).catch(e => console.log("Audio autoplay prevented"));
            } else {
                audio.pause();
                musicBtn.classList.remove('music-active');
                musicBtn.innerHTML = '<i class="fa-solid fa-music text-lg"></i>';
            }
        };

        window.startExperience = () => {
            if(!audio) audio = document.getElementById('bg-music');
            if (audio.paused) {
                toggleMusic();
            } else {
                musicBtn.classList.add('music-active');
                musicBtn.innerHTML = '<i class="fa-solid fa-volume-high text-lg"></i>';
            }
        };

        async function init() {
            initThree();
            generateDefaultTexture();
            
            createTreeSystem();
            
            // Start loading model points in background
            preloadModelPoints();

            animate();

            loadingScreen.style.opacity = '0';
            setTimeout(() => loadingScreen.remove(), 1500);

            statusText.innerText = "INITIALIZING VISION...";
            try {
                await initMediaPipe();
            } catch (e) {
                console.error("Camera failed:", e);
                statusText.innerText = "MANUAL MODE";
                statusDot.classList.add('bg-red-500');
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020a0f, 0.012);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.8, 0.4, 0.85);
            bloomPass.threshold = 0.15; 
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0x333344)); 
            const sunLight = new THREE.DirectionalLight(0xffddaa, 1.5);
            sunLight.position.set(20, 50, 30);
            scene.add(sunLight);

            const bottomLight = new THREE.PointLight(0xffaa55, 4, 80);
            bottomLight.position.set(0, -30, 15);
            scene.add(bottomLight);

            rotatingPointLight = new THREE.PointLight(0x00ffaa, 3, 60);
            rotatingPointLight.position.set(30, 10, 0);
            scene.add(rotatingPointLight);
            
            scene.add(mainGroup);

            window.addEventListener('resize', onResize);
            document.getElementById('file-input').addEventListener('change', onFileUpload);
        }

        function generateDefaultTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 256; cvs.height = 256; 
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#f8f8f8');
            gradient.addColorStop(1, '#e0e0e0');
            ctx.fillStyle = gradient; ctx.fillRect(0,0,256,256);
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#D4AF37'; ctx.strokeRect(10,10,236,236);
            ctx.fillStyle = '#D4AF37';
            ctx.beginPath();
            ctx.moveTo(40, 180); ctx.lineTo(100, 80); ctx.lineTo(160, 180); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(130, 180); ctx.lineTo(180, 110); ctx.lineTo(230, 180); ctx.fill();
            ctx.beginPath();
            ctx.arc(190, 60, 20, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#888'; ctx.font = 'bold 24px Cinzel'; ctx.textAlign = 'center'; 
            ctx.fillText('MEMORY', 128, 220);
            defaultPhotoTexture = new THREE.CanvasTexture(cvs);
        }

        function createTreeSystem() {
            const geo = new THREE.IcosahedronGeometry(0.7, 0); 
            const geoSmall = new THREE.IcosahedronGeometry(0.4, 0); 
            const geoPhoto = new THREE.PlaneGeometry(5.0, 6.0); 

            const matGreen = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.matteGreen, roughness: 0.5, metalness: 0.3,
                emissive: CONFIG.colors.matteGreen, emissiveIntensity: 0.3
            });
            const matRed = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.red, roughness: 0.2, metalness: 0.6,
                emissive: CONFIG.colors.red, emissiveIntensity: 0.8
            });
            const matGold = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold, roughness: 0.1, metalness: 1.0,
                emissive: CONFIG.colors.gold, emissiveIntensity: 1.2
            });
            
            const photoIndices = new Set();
            while(photoIndices.size < CONFIG.photoCount) {
                const idx = Math.floor(Math.random() * (CONFIG.treeParticles * 0.5)) + (CONFIG.treeParticles * 0.25);
                photoIndices.add(idx);
            }

            let photoIter = 0; 

            for(let i = 0; i < CONFIG.treeParticles; i++) {
                let mesh, mat;
                let isPhoto = photoIndices.has(i);
                let baseScale = 1;
                
                const p = i / CONFIG.treeParticles;
                const h = CONFIG.treeHeight;
                let angle = p * Math.PI * 30 + i * 0.1;
                const r = Math.pow((1 - p), 0.8) * CONFIG.treeRadius;
                const y = (p * h) - (h / 2);

                if (isPhoto) {
                    angle = (photoIter / CONFIG.photoCount) * Math.PI * 2; 
                    photoIter++;
                    mat = new THREE.MeshStandardMaterial({
                        map: defaultPhotoTexture, side: THREE.DoubleSide,
                        roughness: 0.3, metalness: 0.2,
                        emissive: 0xffffff, emissiveMap: defaultPhotoTexture, emissiveIntensity: 0
                    });
                    mesh = new THREE.Mesh(geoPhoto, mat);
                } else {
                    const rand = Math.random();
                    if (rand > 0.82) { mat = matGold; baseScale = Math.random()*0.6 + 0.3; }
                    else if (rand > 0.70) { mat = matRed; baseScale = Math.random()*0.7 + 0.5; }
                    else { mat = matGreen; baseScale = Math.random()*0.8 + 0.6; }
                    const g = Math.random() > 0.3 ? geo : geoSmall;
                    mesh = new THREE.Mesh(g, mat.clone());
                    mesh.scale.set(baseScale, baseScale, baseScale);
                }

                const jitter = 2.0; 
                const tx = Math.cos(angle) * r + (Math.random()-0.5)*jitter;
                const tz = Math.sin(angle) * r + (Math.random()-0.5)*jitter;
                const treePos = new THREE.Vector3(tx, y, tz);

                const dist = Math.sqrt(tx*tx + tz*tz);
                const scatterFactor = 15 / (dist + 0.5) + 1.0; 
                const scatterPos = treePos.clone();
                scatterPos.x *= scatterFactor;
                scatterPos.z *= scatterFactor;
                scatterPos.y *= 1.2; 
                const scatterRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                mesh.position.copy(treePos);
                if(isPhoto) mesh.lookAt(tx*2, y, tz*2); 
                else mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                mainGroup.add(mesh);
                
                treeGroup.push({
                    mesh,
                    treePos, treeRot: mesh.rotation.clone(),
                    scatterPos, scatterRot,
                    isPhoto,
                    baseEmissive: mat.emissiveIntensity,
                    blinkSpeed: Math.random() * 0.08 + 0.03,
                    blinkOffset: Math.random() * Math.PI * 2,
                    blinkPhase: Math.random() * Math.PI 
                });
            }

            const starGeo = new THREE.OctahedronGeometry(3.0, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, emissive: 0xffee88, emissiveIntensity: 4.0, roughness: 0.1, metalness: 1.0
            });
            const star = new THREE.Mesh(starGeo, starMat);
            const starY = (CONFIG.treeHeight/2) + 3;
            star.position.set(0, starY, 0);
            mainGroup.add(star);
            const starLight = new THREE.PointLight(0xffee88, 2, 30);
            starLight.position.copy(star.position);
            mainGroup.add(starLight);

            treeGroup.push({
                mesh: star,
                treePos: new THREE.Vector3(0, starY, 0), treeRot: new THREE.Euler(0,0,0),
                scatterPos: new THREE.Vector3(0, starY + 20, 0), scatterRot: new THREE.Euler(Math.PI/4, Math.PI/4, 0),
                isPhoto: false,
                baseEmissive: 4.0,
                blinkSpeed: 0.02, blinkOffset: 0, blinkPhase: 0
            });
        }

        async function preloadModelPoints() {
            try {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('jesus_model.glb');
                let mesh = null;
                gltf.scene.traverse(child => { if (child.isMesh && !mesh) mesh = child; });
                if (!mesh) return;
                
                const sampler = new MeshSurfaceSampler(mesh).build();
                const tempPosition = new THREE.Vector3();
                const rotationAxis = new THREE.Vector3(0, 1, 0);
                const rotationAngle = -Math.PI / 2; 

                // Generate a large pool of points
                for (let i = 0; i < 7000; i++) {
                    sampler.sample(tempPosition);
                    tempPosition.applyAxisAngle(rotationAxis, rotationAngle);
                    cachedModelPoints.push(tempPosition.clone().multiplyScalar(20).add(new THREE.Vector3(0, 16, 0))); 
                }
            } catch (error) {
                console.warn("GLB load failed, using fallback");
                // Fallback sphere
                for(let i=0; i<7000; i++) {
                    const vec = new THREE.Vector3().randomDirection().multiplyScalar(15);
                    cachedModelPoints.push(vec);
                }
            }
        }

        // Modified to be called after form submit
        async function initSpiritSystem(customText) {
            // Cleanup existing spirit particles
            if (spiritGroup.length > 0) {
                spiritGroup.forEach(p => {
                    mainGroup.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                });
                spiritGroup = [];
            }

            const matSpirit = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3, metalness: 1.0,
                emissive: CONFIG.colors.spiritGold,
                emissiveIntensity: 1.5,
                transparent: true,
                opacity: 0
            });
            const geo = new THREE.BoxGeometry(0.12, 0.12, 0.12); 

            // Update text generation with larger canvas
            const textPoints = await generateTextPoints(customText); 
            
            // Use cached points
            // Adjust count based on text length to stay within budget
            const modelCount = Math.max(1000, Math.min(cachedModelPoints.length, CONFIG.spiritParticles - textPoints.length));
            const modelPoints = cachedModelPoints.slice(0, modelCount);

            const allPoints = [...modelPoints, ...textPoints];

            allPoints.forEach(pos => {
                const mesh = new THREE.Mesh(geo, matSpirit.clone());
                mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                mesh.scale.set(0,0,0);
                mainGroup.add(mesh);

                spiritGroup.push({
                    mesh,
                    targetPos: pos, 
                    blinkSpeed: Math.random() * 0.1 + 0.1,
                    blinkOffset: Math.random() * Math.PI * 2,
                    baseEmissive: 1.5
                });
            });
        }

        function generateTextPoints(textStr) {
            return new Promise(resolve => {
                const cvs = document.createElement('canvas');
                // Increased canvas size significantly to fit multiple lines
                const sizeW = 1024; const sizeH = 512; 
                cvs.width = sizeW; cvs.height = sizeH; 
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,sizeW,sizeH);
                ctx.fillStyle = '#fff'; ctx.font = 'bold 48px Cinzel'; 
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                
                const lines = textStr.split('\n');
                // Centering logic
                const lineHeight = 60;
                const totalHeight = lines.length * lineHeight;
                const startY = (sizeH - totalHeight) / 2 + (lineHeight/2);

                lines.forEach((line, i) => { 
                    ctx.fillText(line, sizeW/2, startY + (i*lineHeight)); 
                });

                const data = ctx.getImageData(0,0,sizeW,sizeH).data;
                const points = [];
                const step = 4; 
                for(let y=0; y<sizeH; y+=step) {
                    for(let x=0; x<sizeW; x+=step) {
                        const alpha = data[(y*sizeW + x)*4]; 
                        if(alpha > 128) {
                            const px = (x / sizeW) * 90 - 45;
                            // Re-mapped Y for larger canvas height (512px)
                            // 56 units total height spread, centered at +2
                            const py = -((y / sizeH) * 56 - 28) + 2; 
                            const pt = new THREE.Vector3(px, py, 12);
                            points.push(pt);
                        }
                    }
                }
                resolve(points);
            });
        }

        function switchState(newState) {
            if (currentMode === newState) return;
            currentMode = newState;

            document.getElementById('badge-tree').classList.toggle('state-active', newState === 'tree');
            document.getElementById('badge-christus').classList.toggle('state-active', newState === 'christus');
            document.getElementById('badge-zoom').classList.toggle('state-active', newState === 'zoom');

            const dur = 2000; 

            treeGroup.forEach(p => {
                let target, targetRot;
                if (newState === 'tree') {
                    target = p.treePos; targetRot = p.treeRot;
                } else if (newState === 'zoom' && p.isPhoto) {
                    target = p.scatterPos.clone().multiplyScalar(0.7); 
                    target.z += 10; 
                    targetRot = new THREE.Euler(0, 0, 0); 
                } else {
                    target = p.scatterPos; targetRot = p.scatterRot;
                }
                new TWEEN.Tween(p.mesh.position).to(target, dur).easing(TWEEN.Easing.Quintic.InOut).start();
                if (p.isPhoto && newState === 'zoom') {
                    new TWEEN.Tween(p.mesh.rotation).to({x:0, y:0, z:0}, dur).start();
                    new TWEEN.Tween(p.mesh.scale).to({x:2, y:2, z:2}, dur).start();
                } else {
                    new TWEEN.Tween(p.mesh.rotation).to({x: targetRot.x, y: targetRot.y, z: targetRot.z}, dur).easing(TWEEN.Easing.Quintic.InOut).start();
                    new TWEEN.Tween(p.mesh.scale).to({x:1, y:1, z:1}, dur).start();
                }
                if (!p.isPhoto) {
                    const targetInt = newState === 'tree' ? p.baseEmissive : p.baseEmissive * 1.5; 
                    new TWEEN.Tween(p.mesh.material).to({ emissiveIntensity: targetInt }, dur).start();
                }
            });

            spiritGroup.forEach(p => {
                let targetScale, targetOpacity;
                if (newState === 'christus') {
                    targetScale = 2.0; targetOpacity = 1;
                    new TWEEN.Tween(p.mesh.position).to(p.targetPos, dur).easing(TWEEN.Easing.Quintic.Out).delay(Math.random() * 600).start();
                } else {
                    targetScale = 0; targetOpacity = 0;
                    const randomHidePos = { x: (Math.random()-0.5)*50, y: (Math.random()-0.5)*50+20, z: (Math.random()-0.5)*50 };
                    new TWEEN.Tween(p.mesh.position).to(randomHidePos, dur).easing(TWEEN.Easing.Cubic.In).start();
                }
                new TWEEN.Tween(p.mesh.scale).to({x: targetScale, y: targetScale, z: targetScale}, dur).start();
                new TWEEN.Tween(p.mesh.material).to({ opacity: targetOpacity }, dur).start();
            });
        }

        function onFileUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image();
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true; tex.colorSpace = THREE.SRGBColorSpace;
                        photoTextures.push(tex);
                        updatePhotos();
                    };
                    img.src = ev.target.result;
                };
                r.readAsDataURL(f);
            });
        }

        function updatePhotos() {
            let idx = 0;
            treeGroup.forEach(p => {
                if(p.isPhoto && photoTextures.length) {
                    const tex = photoTextures[idx % photoTextures.length];
                    p.mesh.material.map = tex;
                    p.mesh.material.emissiveMap = tex;
                    p.mesh.material.needsUpdate = true;
                    idx++;
                }
            });
        }

        async function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraObj = new Camera(videoInput, {
                onFrame: async () => { if (videoInput.readyState >= 2) await hands.send({image: videoInput}); },
                width: 320, height: 240, facingMode: 'user'
            });
            await cameraObj.start();
        }

        function onResults(res) {
            if(!res.multiHandLandmarks.length) {
                statusDot.classList.remove('bg-green-500', 'status-active');
                return;
            }
            if(!isCameraReady) {
                isCameraReady = true;
                statusText.innerText = "GESTURE ACTIVE";
                statusDot.classList.add('bg-green-500', 'shadow-[0_0_5px_rgba(0,255,0,0.5)]');
                videoContainer.style.opacity = 0.3; 
            }

            const lm = res.multiHandLandmarks[0];
            
            let openFingers = 0;
            [8,12,16,20].forEach(t => { if(lm[t].y < lm[t-2].y) openFingers++; });
            
            const isVictory = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y && lm[20].y > lm[18].y;

            if (openFingers >= 4) {
                switchState('christus');
            } else if (isVictory) {
                switchState('zoom');
            } else {
                switchState('tree');
            }

            const palmX = (lm[0].x + lm[5].x + lm[17].x) / 3;
            const palmY = (lm[0].y + lm[5].y + lm[17].y) / 3;
            
            targetRotationY = (palmX - 0.5) * -2.5; 
            targetRotationX = (palmY - 0.5) * 1.0; 
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.015; 
            TWEEN.update();

            rotatingPointLight.position.x = Math.cos(time * 0.5) * 35;
            rotatingPointLight.position.z = Math.sin(time * 0.5) * 35;
            rotatingPointLight.position.y = Math.sin(time * 0.3) * 20 + 10;
            const lightColor = new THREE.Color().setHSL(Math.sin(time * 0.2) * 0.1 + 0.55, 1.0, 0.5); 
            rotatingPointLight.color.copy(lightColor);

            if (currentMode === 'tree') {
                mainGroup.rotation.y += 0.002; 
                mainGroup.rotation.x += (0 - mainGroup.rotation.x) * 0.05;
            } else {
                if (isCameraReady) {
                    mainGroup.rotation.y += (targetRotationY - mainGroup.rotation.y) * 0.03;
                    mainGroup.rotation.x += (targetRotationX - mainGroup.rotation.x) * 0.03;
                } else {
                    mainGroup.rotation.y = Math.sin(time * 0.15) * 0.08;
                    mainGroup.rotation.x = Math.sin(time * 0.1) * 0.04;
                }
            }

            treeGroup.forEach(p => {
                if (!p.isPhoto) {
                    const wave1 = Math.sin(time / p.blinkSpeed + p.blinkOffset);
                    const wave2 = Math.cos(time / (p.blinkSpeed*1.5) + p.blinkPhase);
                    const blink = (wave1 + wave2) / 2; 
                    const currentBase = currentMode === 'tree' ? p.baseEmissive : p.baseEmissive * 1.3;
                    const blinkIntensity = currentMode === 'tree' ? 0.5 : 0.8;
                    p.mesh.material.emissiveIntensity = currentBase + (blink * blinkIntensity);
                    
                    if (p.mesh.material.color.getHex() === CONFIG.colors.red) {
                        const hue = 0.0 + (blink + 1) * 0.02; 
                        p.mesh.material.color.setHSL(hue, 1.0, 0.5);
                        p.mesh.material.emissive.setHSL(hue, 1.0, 0.5);
                    }
                } else {
                    const targetInt = currentMode === 'zoom' ? 1.0 : 0.0;
                    p.mesh.material.emissiveIntensity += (targetInt - p.mesh.material.emissiveIntensity) * 0.05;
                }
            });

            if (currentMode === 'christus') {
                spiritGroup.forEach(p => {
                    const blink = Math.sin(time * 5 + p.blinkOffset);
                    p.mesh.material.emissiveIntensity = 1.8 + (blink * 0.6);
                });
            }

            composer.render();
        }

        // Start initialization but delay spirit system creation until form submit
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
